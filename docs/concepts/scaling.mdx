---
title: Scaling & Concurrency
icon: maximize
---

This document covers how workers are able to scale better than traditional applications & provides tips on architecting your workers.

## How workers scale

Workers scale by design through these key properties:

| Property                             | Description                                                                                                                                                                                                                                                                                     |
| ------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Independent State**                | Each worker manages its own private data separately from other workers, so they never conflict with each other when running at the same time (i.e. using locking mechanisms).                                                                                                                     |
| **Action- & Event-Based Communication** | Workers communicate through asynchronous [actions](/concepts/actions) or [events](/concepts/events), making it easy to distribute them across different machines.                                                                                                                                               |
| **Location Transparency**            | Unlike traditional servers, workers don't need to know which machine other workers are running on in order to communicate with each other. They can run on the same machine, across a network, and across the world. Workers handle the network routing for you under the hood.                    |
| **Horizontal Scaling**               | Workers distribute workload by splitting responsibilities into small, focused units. Since each worker handles a limited scope (like a single user, document, or chat room), the system automatically spreads load across many independent workers rather than concentrating it in a single place. |

## Tips for architecting workers for scale

Here are key principles for architecting your worker system:

**Single Responsibility**

- Each worker should represent one specific entity or concept from your application (e.g., `User`, `Document`, `ChatRoom`).
- This makes your system scale better, since workers have small scopes and do not conflict with each other.

**State Management**

- Each worker owns and manages only its own state
- Use [actions](/concepts/actions) to request data from other workers
- Keep state minimal and relevant to the worker's core responsibility

**Granularity Guidelines**

- Too coarse: Workers handling too many responsibilities become bottlenecks
- Too fine: Excessive workers create unnecessary communication overhead
- Aim for workers that can operate independently with minimal cross-worker communication

### Examples

**Good worker boundaries**

- `User`: Manages user profile, preferences, and authentication
- `Document`: Handles document content, metadata, and versioning
- `ChatRoom`: Manages participants and message history

**Poor worker boundaries**

- `Application`: Too broad, handles everything
- `DocumentWordCount`: Too granular, should be part of DocumentWorker
