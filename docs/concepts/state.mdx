---
title: State
icon: floppy-disk
---

Actor state provides the best of both worlds: it's stored in-memory and persisted automatically. This lets you work with the data without added latency while still being able to survive crashes & upgrades.

<Tip>
**Using External SQL Databases**

Actors can also be used with external SQL databases. This can be useful to integrate actors with existing
applications or for storing relational data. Read more [here](/concepts/external-sql).
</Tip>

## Initializing State

There are two ways to define an actor's initial state:

### Method 1: Static Initial State

```typescript
import { actor } from "actor-core";

// Simple state with a constant
const counter = actor({
  // Define state as a constant
  state: { count: 0 },
  
  actions: {
    // ...
  }
});
```

### Method 2: Dynamic Initial State

```typescript
import { actor } from "actor-core";

// State with initialization logic
const counter = actor({
  // Define state using a creation function
  createState: () => {
    return { count: 0 };
  },
  
  actions: {
    // ...
  }
});
```

The `createState` function is called once when the actor is first created. See [Lifecycle](/concepts/lifecycle) for more details.

## Modifying State

To update state, modify the `state` property on the context object (`c.state`) in your actions:

```typescript
import { actor } from "actor-core";

const counter = actor({
  state: { count: 0 },
  
  actions: {
    // Define action to update state
    increment: (c) => {
      // Update state, this will automatically be persisted
      c.state.count += 1;
      return c.state.count;
    },
    
    add: (c, value) => {
      c.state.count += value;
      return c.state.count;
    }
  }
});
```

<Note>
Only state stored in the `state` object will be persisted. Any other variables or properties outside of this are not persisted.
</Note>

## State Saves

Actors automatically handle persisting state transparently. This happens at the end of every action if the state has changed.

In the rare occasion you need to force a state change mid-action, you can use `c.saveState()`. This should only be used if your action makes an important state change that needs to be persisted before the action completes.

```typescript
import { actor } from "actor-core";

const criticalProcess = actor({
  state: { 
    steps: [],
    currentStep: 0
  },
  
  actions: {
    processStep: async (c) => {
      // Update to current step
      c.state.currentStep += 1;
      c.state.steps.push(`Started step ${c.state.currentStep}`);
      
      // Force save state before the async operation
      c.saveState();
      
      // Long-running operation that might fail
      await someRiskyOperation();
      
      // Update state again
      c.state.steps.push(`Completed step ${c.state.currentStep}`);
      
      return c.state.currentStep;
    }
  }
});
```

## State Isolation

Each actor's state is completely isolated, meaning it cannot be accessed directly by other actors or clients. This allows actors to maintain a high level of security and data integrity, ensuring that state changes are controlled and predictable.

To interact with an actor's state, you must use [Actions](/concepts/actions). Actions provide a controlled way to read from and write to the state.

## Sharing State Between Actors

If you need a shared state between multiple actors, you have two options:

1. Create an actor that holds the shared state that other actors can make action calls to
2. Use an external database, see [External SQL Databases](/concepts/external-sql)

## Limitations

State is constrained to the available memory.

Only JSON-serializable types can be stored in state. In serverless runtimes that support it (Rivet, Cloudflare Workers), state is persisted under the hood in a compact, binary format. This is because JavaScript classes cannot be serialized & deserialized.
