---
title: Connections
icon: network-wired
---

Connections represent client connections to your actor. They provide a way to handle client authentication, manage connection-specific data, and control the connection lifecycle.

## Parameters

When clients connect to an actor, they can pass connection parameters that are handled during the connection process.

For example:

<CodeGroup>

```typescript actor.ts
import { actor } from "actor-core";

const gameRoom = actor({
  state: {},
  
  // Handle connection setup
  createConnectionState: (c) => {
    // Validate authentication token
    const authToken = c.parameters.authToken;
    
    if (!authToken || !validateToken(authToken)) {
      throw new Error("Invalid auth token");
    }
    
    // Create connection state
    return { userId: getUserIdFromToken(authToken), role: "player" };
  },
  
  actions: {
    // ...
  }
});
```

```typescript client.ts
import { createClient } from "actor-core/client";
import type { App } from "./src/index";

const client = createClient<App>("http://localhost:6420");
const gameRoom = await client.gameRoom.get({
  parameters: { authToken: "supersekure" }
});
```

</CodeGroup>

## Connection State

There are two ways to define an actor's connection state:

### Method 1: `connectionState` constant

```typescript
import { actor } from "actor-core";

const chatRoom = actor({
  state: { messages: [] },
  
  // Define default connection state as a constant
  connectionState: {
    role: "guest",
    joinedAt: 0
  },
  
  onConnect: (c) => {
    // Update join timestamp when a client connects
    c.connection.state.joinedAt = Date.now();
  },
  
  actions: {
    // ...
  }
});
```

### Method 2: `createConnectionState` function

The data returned from `createConnectionState` is used as the initial state of the connection. The connection state can be accessed through `connection.state`.

```typescript
import { actor } from "actor-core";

const chatRoom = actor({
  state: { messages: [] },
  
  // Create connection state dynamically
  createConnectionState: (c) => {
    // Validate any connection parameters
    // ...
    
    // Return the connection state
    return { 
      userId: generateUserId(),
      role: "guest",
      joinedAt: Date.now()
    };
  },
  
  actions: {
    sendMessage: (c, message) => {
      const username = c.connection.state.userId;
      c.state.messages.push({ username, message });
      c.broadcast("newMessage", { username, message });
    }
  }
});
```

## Lifecycle Hooks

The connection lifecycle has several hooks:

- `onBeforeConnect`: Called before a client connects, returns the connection state
- `onConnect`: Called when a client successfully connects
- `onDisconnect`: Called when a client disconnects

See the documentation on [Actor Lifecycle](/concepts/lifecycle) for more details.

## Connection List

All active connections can be accessed through the context object's `connections` property. This is an array of all current connections.

This is frequently used with `conn.send(name, event)` to send messages directly to clients.

For example:

```typescript
import { actor } from "actor-core";

const chatRoom = actor({
  state: { users: {} },
  
  actions: {
    sendDirectMessage: (c, recipientId, message) => {
      // Find the recipient's connection
      const recipientConn = c.connections.find(conn => conn.state.userId === recipientId);
      
      if (recipientConn) {
        // Send a private message to just that client
        recipientConn.send('directMessage', {
          from: c.connection.state.userId,
          message: message
        });
      }
    }
  }
});
```

## Disconnecting clients

Connections can be disconnected from within an action:

```typescript
import { actor } from "actor-core";

const secureRoom = actor({
  state: {},
  
  actions: {
    kickUser: (c, targetUserId, reason) => {
      // Find the connection to kick
      const targetConn = c.connections.find(conn => conn.state.userId === targetUserId);
      
      if (targetConn) {
        // Disconnect with a reason
        targetConn.disconnect(reason || "Kicked by admin");
      }
    }
  }
});
```

<Tip>
If you need to wait for the disconnection to complete, you can use `await`:

```typescript
await connection.disconnect('Too many requests');
```

This ensures the underlying network connections close cleanly before continuing.
</Tip>

## Offline & Auto-Reconnection

See [Interacting with Actors](/concepts/interacting-with-actors#offline-and-auto-reconnection) for details on reconnection behavior.
