---
title: Rivet Workers
icon: square-info
sidebarTitle: "Overview"
description: A library for building stateful, scalable, realtime backend applications.
---

import CreateWorkerCli from "/snippets/create-worker-cli.mdx";

Workers combine compute and storage into unified entities for simplified architecture. Workers seamlessly integrate with your existing infrastructure or can serve as a complete standalone solution.

## Concepts

The core concepts that power Rivet Worker applications:

- **State Is Automatically Persisted**: State automatically persists between restarts, upgrades, & crashes
- **State Is Stored In-Memory**: State is stored in memory for high-performance reads/writes while also automatically persisted
- **Isolated State Ownership**: Workers only manage their own state, which can only be modified by the worker itself
- **Communicates via Actions**: How clients and other workers interact with a worker
- **Actions Are Low-Latency**: Actions provide WebSocket-like performance for time-sensitive operations
- **Broadcast Updates With Events**: Workers can publish real-time updates to connected clients

## Quickstart

Run this to get started:

<CreateWorkerCli />

## Code Example

Here's a complete chat room worker that maintains state and handles messages. We'll explore each component in depth throughout this document:

```typescript chat_room.ts
import { worker } from "rivetkit";

// Define a chat room worker
const chatRoom = worker({
  // Initialize state when the worker is first created
  createState: () => ({
    messages: []
  }),

  // Define actions clients can call
  actions: {
    // Action to send a message
    sendMessage: (c, sender, text) => {
      // Update state
      c.state.messages.push({ sender, text });
      
      // Broadcast to all connected clients
      c.broadcast("newMessage", { sender, text });
    },
    
    // Action to get chat history
    getHistory: (c) => {
      return c.state.messages;
    }
  }
});

export default chatRoom;
```

## Using the App

To start using your worker, create an app and serve it:

```typescript app.ts
import { setup, serve } from "rivetkit";
import chatRoom from "./chat_room";

// Create the application
const registry = setup({
  workers: { chatRoom }
});

// Start serving on default port
serve(registry);

// Export the app type for client usage
export type Registry = typeof registry;
```

## Key Worker Components

### State

Workers maintain state that's stored in memory and automatically persisted. State is defined either as a constant or via a `createState` function:

```typescript
import { worker } from "rivetkit";

// Method 1: State constant
const counter1 = worker({
  state: { count: 0 },
  actions: {
    // ...
  }
});

// Method 2: CreateState function
const counter2 = worker({
  createState: () => ({ count: 0 }),
  actions: {
    // ...
  }
});
```

Update state by modifying `c.state` in your actions:

```typescript
import { worker } from "rivetkit";

const counter = worker({
  state: { count: 0 },
  actions: {
    // Example of state update in an action
    increment: (c) => {
      c.state.count += 1;
      return c.state.count;
    }
  }
});
```

These changes are durable and are automatically persisted across updates, restarts, and crashes.

Learn more about [state management](/worker/state).

### Actions

Actions are functions defined in your worker configuration that clients & other workers can call:

```typescript
import { worker } from "rivetkit";

const mathUtils = worker({
  state: {},
  actions: {
    multiplyByTwo: (c, x) => {
      return x * 2;
    }
  }
});
```

Each action receives a context object (commonly named `c`) as its first parameter, which provides access to state, connections, and other utilities.

Learn more about [actions](/worker/actions).

### Events

Workers can broadcast events to connected clients:

```typescript
import { worker } from "rivetkit";

const inventory = worker({
  createState: () => ({ 
    items: [] 
  }),
  
  actions: {
    addItem: (c, item) => {
      // Add to state
      c.state.items.push(item);
      
      // Notify all clients about the new item
      c.broadcast("itemAdded", { item });
    }
  }
});
```

You can also send events to specific clients:

```typescript
import { worker } from "rivetkit";

const messageService = worker({
  state: {},
  actions: {
    sendPrivateMessage: (c, userId, text) => {
      // Send to a specific connection
      const conn = c.conns.find(conn => conn.params.userId === userId);
      if (conn) {
        conn.send("privateMessage", { text });
      }
    }
  }
});
```

Learn more about [events](/worker/events).

## Worker Tags

Tags are key-value pairs attached to workers that serve two purposes:

1. **Worker Discovery**: Find specific workers using `client.get(tags)`
2. **Organization**: Group related workers for management purposes

For example, you can query chat rooms by tag like:

```typescript client.ts
await client.chatRoom.get({ channel: "random" });
```

### Common Tag Patterns

```typescript
import { createClient } from "rivetkit/client";
import type { App } from "./src/index";

const client = createClient<App>("http://localhost:6420");

// Game room with ID parameter
const gameRoom = await client.gameRoom.get({ roomId: "ABC123" });

// User profile with ID
const userProfile = await client.userProfile.get({ profileId: "1234" });

// Document with multiple parameters
const document = await client.document.get({
  workspaceId: "team-alpha",
  documentId: "budget-2024"
});
```

## Worker Lifecycle

Workers are created automatically when needed and persist until explicitly shutdown.

To shut down a worker, use `c.shutdown()` from within an action:

```typescript
import { worker } from "rivetkit";

const chatRoom = worker({
  createState: () => ({
    messages: []
  }),
  actions: {
    closeRoom: (c) => {
      // Do any cleanup needed
      c.broadcast("roomClosed");
      
      // Shutdown the worker
      c.shutdown();
    }
  }
});
```

Learn more about the [worker lifecycle](/worker/lifecycle).

## Documentation

Learn more about Rivet Workers:

<CardGroup cols={2}>
  <Card title="Quickstart" icon="forward" href="/worker/quickstart">
    Get started with Rivet Workers in minutes
  </Card>
  <Card title="State" icon="floppy-disk" href="/worker/state">
    Understand how worker state is managed, persisted, and accessed.
  </Card>
  <Card title="Actions" icon="bolt" href="/worker/actions">
    Define and implement worker actions (RPCs) for client interaction.
  </Card>
  <Card title="Events" icon="tower-broadcast" href="/worker/events">
    Real-time communication with events and broadcasts.
  </Card>
  <Card title="Lifecycle" icon="rotate" href="/worker/lifecycle">
    Managing the creation, execution, and termination of workers.
  </Card>
  <Card title="Schedule" icon="clock" href="/worker/schedule">
    Schedule tasks and alarms with workers for time-based operations.
  </Card>
</CardGroup>
