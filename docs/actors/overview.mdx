---
title: Rivet Actors
icon: square-info
sidebarTitle: "Overview"
description: A library for building stateful, scalable, realtime backend applications.
---

import CreateActorCli from "/snippets/create-actor-cli.mdx";

Actors combine compute and storage into unified entities for simplified architecture. Actors seamlessly integrate with your existing infrastructure or can serve as a complete standalone solution.

## Quickstart

<CardGroup>
<Card title="Node.js & Bun" icon="node-js" />
<Card title="React" icon="react" />
</CardGroup>

## Concepts

The core concepts that power Rivet Actor applications:

- **State Is Automatically Persisted**: State automatically persists between restarts, upgrades, & crashes
- **State Is Stored In-Memory**: State is stored in memory for high-performance reads/writes while also automatically persisted
- **Isolated State Ownership**: Actors only manage their own state, which can only be modified by the actor itself
- **Communicates via Actions**: How clients and other actors interact with a actor
- **Actions Are Low-Latency**: Actions provide WebSocket-like performance for time-sensitive operations
- **Broadcast Updates With Events**: Actors can publish real-time updates to connected clients

## Quickstart

Run this to get started:

<CreateActorCli />

## Code Example

Here's a complete chat room actor that maintains state and handles messages. We'll explore each component in depth throughout this document:

```typescript chat_room.ts
import { actor } from "rivetkit";

// Define a chat room actor
const chatRoom = actor({
  // Initialize state when the actor is first created
  createState: () => ({
    messages: []
  }),

  // Define actions clients can call
  actions: {
    // Action to send a message
    sendMessage: (c, sender, text) => {
      // Update state
      c.state.messages.push({ sender, text });
      
      // Broadcast to all connected clients
      c.broadcast("newMessage", { sender, text });
    },
    
    // Action to get chat history
    getHistory: (c) => {
      return c.state.messages;
    }
  }
});

export default chatRoom;
```

## Using the App

To start using your actor, create an app and serve it:

```typescript app.ts
import { setup, serve } from "rivetkit";
import chatRoom from "./chat_room";

// Create the application
const registry = setup({
  use: { chatRoom }
});

// Start serving on default port
serve(registry);
```

## Key Actor Components

### State

Actors maintain state that's stored in memory and automatically persisted. State is defined either as a constant or via a `createState` function:

```typescript
import { actor } from "rivetkit";

// Method 1: State constant
const counter1 = actor({
  state: { count: 0 },
  actions: {
    // ...
  }
});

// Method 2: CreateState function
const counter2 = actor({
  createState: () => ({ count: 0 }),
  actions: {
    // ...
  }
});
```

Update state by modifying `c.state` in your actions:

```typescript
import { actor } from "rivetkit";

const counter = actor({
  state: { count: 0 },
  actions: {
    // Example of state update in an action
    increment: (c) => {
      c.state.count += 1;
      return c.state.count;
    }
  }
});
```

These changes are durable and are automatically persisted across updates, restarts, and crashes.

Learn more about [state management](/actor/state).

### Actions

Actions are functions defined in your actor configuration that clients & other actors can call:

```typescript
import { actor } from "rivetkit";

const mathUtils = actor({
  state: {},
  actions: {
    multiplyByTwo: (c, x) => {
      return x * 2;
    }
  }
});
```

Each action receives a context object (commonly named `c`) as its first parameter, which provides access to state, connections, and other utilities.

Learn more about [actions](/actor/actions).

### Events

Actors can broadcast events to connected clients:

```typescript
import { actor } from "rivetkit";

const inventory = actor({
  createState: () => ({ 
    items: [] 
  }),
  
  actions: {
    addItem: (c, item) => {
      // Add to state
      c.state.items.push(item);
      
      // Notify all clients about the new item
      c.broadcast("itemAdded", { item });
    }
  }
});
```

You can also send events to specific clients:

```typescript
import { actor } from "rivetkit";

const messageService = actor({
  state: {},
  actions: {
    sendPrivateMessage: (c, userId, text) => {
      // Send to a specific connection
      const conn = c.conns.find(conn => conn.params.userId === userId);
      if (conn) {
        conn.send("privateMessage", { text });
      }
    }
  }
});
```

Learn more about [events](/actor/events).

## Actor Tags

Tags are key-value pairs attached to actors that serve two purposes:

1. **Actor Discovery**: Find specific actors using `client.get(tags)`
2. **Organization**: Group related actors for management purposes

For example, you can query chat rooms by tag like:

```typescript client.ts
await client.chatRoom.get({ channel: "random" });
```

### Common Tag Patterns

```typescript
import { createClient } from "rivetkit/client";
import type { App } from "./src/index";

const client = createClient<App>("http://localhost:8080");

// Game room with ID parameter
const gameRoom = await client.gameRoom.get({ roomId: "ABC123" });

// User profile with ID
const userProfile = await client.userProfile.get({ profileId: "1234" });

// Document with multiple parameters
const document = await client.document.get({
  workspaceId: "team-alpha",
  documentId: "budget-2024"
});
```

## Actor Lifecycle

Actors are created automatically when needed and persist until explicitly shutdown.

To shut down a actor, use `c.shutdown()` from within an action:

```typescript
import { actor } from "rivetkit";

const chatRoom = actor({
  createState: () => ({
    messages: []
  }),
  actions: {
    closeRoom: (c) => {
      // Do any cleanup needed
      c.broadcast("roomClosed");
      
      // Shutdown the actor
      c.shutdown();
    }
  }
});
```

Learn more about the [actor lifecycle](/actor/lifecycle).

## Documentation

Learn more about Rivet Actors:

<CardGroup cols={2}>
  <Card title="Quickstart" icon="forward" href="/actor/quickstart">
    Get started with Rivet Actors in minutes
  </Card>
  <Card title="State" icon="floppy-disk" href="/actor/state">
    Understand how actor state is managed, persisted, and accessed.
  </Card>
  <Card title="Actions" icon="bolt" href="/actor/actions">
    Define and implement actor actions (RPCs) for client interaction.
  </Card>
  <Card title="Events" icon="tower-broadcast" href="/actor/events">
    Real-time communication with events and broadcasts.
  </Card>
  <Card title="Lifecycle" icon="rotate" href="/actor/lifecycle">
    Managing the creation, execution, and termination of actors.
  </Card>
  <Card title="Schedule" icon="clock" href="/actor/schedule">
    Schedule tasks and alarms with actors for time-based operations.
  </Card>
</CardGroup>
